Task 6: Authorization & Signals
mehdi fekri


Questions to Explore
1. What is @permission_required, and how does it work for function-based views?
خب همان طور که در تسک قبلی Decorator داشتیم و اونم login_required بود در این تسک میخواییم با یکی دیگه از اونا آشنا بشیم که اونم  permission_required هستش.این دیکیریتور برای دسترسی های سطح پایین استفاده میشه و اینطوری هستش که که اگر فرد لاگین نکرده باشه و بخواد به یک ویو دسترسی پیدا کنه اونو به صفحه لاگین میفرسته ولی اگه یکی لاگین کرده باشه و به یک ویو ای که از این دیکیریتور استفاده میکنه بخواد دسترسی پیدا کنه بهش صفحه ۴۰۳ رو نشون میده که ارور Forbidden هستش.
خود جنگو به صورت دیفالت ۳ تا permission داره که شامل add,delete,change هستش و مثلا ما بخواییم از یک دیکیریتوری استفاده کنیم به این صورت استفاده میکنیم مثل بقیه دیکیریتور ها اول تابع میاییم اونو صدا میزنیم و یک permission add بهش میدیم که میاد به این صورت اینو تفسیر میکنه که برای اجرا این ویو باید کاربر اجازه add یا ایجاد رو داشته باشه و اگر نداشته باشه اون اجازه رو بهش نمیده .
جند تا پارامتر هم میتونه به عنوان ووردی بگیره که اینا هم اپشنال هستن و اگر ندیم خودش از دیفالتش استفاده میکنه.
یکیش خود permission هستش که باید اینو مقدار دهی کنیم . یکی هم redirect اون هستش که به کجا ریداریکتش کنه و یکی هم میتونه این باشه raise کنه و مستقیم بیاد error 403 رو بده.
یه نکته دیگه این که میتونیم خودمون پرمیشن هم تعریف کنیم و تو مدل به راحتی میتونیم تو کلاس meta بیاییم permission  رو به راحتی تعریف کنیم و ازش استفاده کنیم. برای دادن permission و اساین کردن اون به کاربران از جنگو ادمین این کار رو میتونیم انجام بدیم. و یا اگر بخواهیم یه موقه خاصی این پرمیشن داده بشه میتونیم تو خود کد هم هندلش کنیم.به این صورت:


user = User.objects.get(username='mehdi')
permission = Permission.objects.get(codename='can_publish')  
user.user_permissions.add(permission)

2. What is PermissionRequiredMixin, and how is it used in class-based views?
خب حالا اگه بخواییم از کلاس ها برای ویو ها استفاده کنیم از mixin ها استفاده میکنیم که این راحت تر از decorator ها هستش.دقیقا میاییم مثل loginrequiredmixin استفاده میکنیم.بعدش داخل کلاس با استفاده از permission_required اون permission های مورد نظرمون رو مشخص میکنیم.

3. What is the effect of setting raise_exception=True?
خب ما از این پارامتر میتونیم تو دیکیریتور ها استفاده کنیم و اگر اینو True بزنیم به جای اینکه به صفحه لاگین یا نمیدونم یه صفحه دیگه ری دایرکت بشه مستقیما به صفحه error 403(Forbidden) ری دایرکت میشه. و از خود اسمش هم معلومه که یک استثنایی رخ داده و میتونیم با استفاده از این خطا ها و ارور ها (۴۰۳و۴۰۱و۴۰۰) رو مدیریت کنیم.

. What is the difference between @login_required and @permission_required?

login_required:
فقط چک میکنه که این کاربر لاگین کرده است یا نه و اگر لاگین نکرده باشه نمیذاره به اون ویو ها درسترسی پیدا کنه و اونارو به صفحه لاگین ری دایرکت میکنه و هیچ کاری با سطح دسترسی و یوسر نداره و برای همه یوسر ها یکسانه .
permission_required:
برای این باید کاربر حتما لاگین کرده باشه و همچنین و دسترسی لازم رو هم نیز داشته باشه و اگر هم این اتفاق نیوفته permission denied  میده .

5. What are Django’s default model permissions (add, change, delete, view)?
تو سوال یک درباره permission های دیفالتی که خود جنگو داره حرف زدیم و گفتیم که این پرمیشن های دیفالت رو داره.
اولیش add هستش که به این معناست که باید کاربر اجازه اد کردن داشته باشه و change هم برای این هستش که کاربر اجازه تغییر دادن رو داشته باشه و delete هم برای حذف کردن هستش .view هم برای این استفاده میشه که کاربر اجازه دیدن رکورد ها اون مدل رو داشته باشه.

6. How can we define custom permissions using Meta.permissions in a model?
برای این سوال هم تو سوال یک یه توضیحی دادم. به این صورت هستش که ما می آییم تو مدل تو کلاس meta که یک رکورد  permission داره رو مقدار دهی میکنیم و بهش permission های کاستومی که میخواییم اضافه کنیم رو اضافه میکنیم و بعد از هم باید migrate کنیم تا تغییراتمون ثبت یشه .و هر permission هم دارای یک code و یک توضیح کوتاه درباره اونه که بفهمیم برای چی هستش 

به این صورت:

class prodoct():
...
...
class Meta:
	permissions = [
			(codename:explain of permission),
			....
			]
 بعد از این وقتی makemigrate رو زدیم و بعدش migrate کردیم این permission ها اضافه میشن و میتونیم تو جنگو ادمین اونارو اساین هم کنیم.
7. How can we use custom permissions using Meta.permissions?
خب من این سوال رو تقریبا تو سوال های قبلی توضیح دادم.
اول تو مدل custom permission هارو ایجاد میکنیم و بعدش makemigrate , migrate رو انجام میدیم و الان اینا به لیست permission ها اضافه شدن.خب بعدش الان به سه روش میتونیم استفاده کنیم.
۱. اینکه الان این permission ها به جنگو ادمین هم اضافه شدن میتونیم از انجا اساین کنیم.
۲.میتونیم گروه ایجاد کنیم و به گروه ها اینو اساین کنیم که اینم از طریق جنگو ادمین انجام میشه.
۳.میتونیم به صورت دستی و تو کد این کارو انجام بدیم که بالا کدش رو اورده بودم الان هم دوباره میارمش:


user = User.objects.get(username='mehdi')
permission = Permission.objects.get(codename='can_publish')  
user.user_permissions.add(permission)

8. How does user.has_perm() work internally?
خب این متود همانطور که از اسمش پیداست میاد چک میکنه که این فرد این  permission ای خاصی رو که ورودی میگیره رو داره یا نه.حالا خروجی و نحوه کار این رو چک  میکنیم:
اگر این user, یک superuser باشه که خروجیش برای هر permission , درست خواهد بود یعنی True.
اگر user اصلا وجود نداشته باشه یا لاگین نکرده باشه یا ثبت نام نکرده باشه False میده.
بعدش اگه اینا چک شد جنگو از دیتابیس یوسر و پرمیشن هارو باید بگیره تا چک کنه و اول اون مدل رو میگیره و بعدش چک میکنه و اگر بخوام یه نقشه راه براش بنویسم به این صورت خواهد بود:
if superuser then true
if authentication no then false
then retrieve users + permission from DB and check them.

9. When should we use model-level permissions instead of hard-coded role checks?
به نظر من بهتره که در کل از model-level permission ها استفاده کنیم ولی خب در پروژه های کوچیک با مدل ها خیلی کمتر و گروه ها و رول ها کمتر میتونیم با کد هم اینو هندل کنیم و کلا استفاده از روش اول انعاف بیشتری و ازادی عمل بیشتری هم میده و میتونیم هر موقع که خواستیم این دسترسی رو هم بگیریم و میتونیم دسترسی های کاستوم تعریف کنیم و خیلی از چیز دیگه
کلا آزادی عمل بیشتری داریم و راحت تر میتونیم کار هامون رو هندل کنیم.
9. What is the difference between assigning permissions to a Group vs directly to a User?
خب مونده به اون کاری که میکنیم میتونیم از یکی از این دو روش استفاده کنیم 
مثلا وقتی که تعداد یوسر ها زیاده و میخواهیم چند تا دسترسی رو به این یوسر ها بدیم بهتره گروه داشته باشیم و اینطوری یه جور ارث بری هم میتونیم داشته باشیم و بعدش میتونیم به یوسر بعد اون دسترسی خاصی رو هم بدیم.ولی وقتی که یک دسترسی خاصی رو به چند یوسر با تعداد خیلی کمتر یا یک یوسر بخواییم بدهیم منطقی هستش که از individual استفاده کنیم و به صورت فردی بهشون دسترسی بدیم .

10. Why are group-based permissions more scalable in real projects?
خب به این دلیل که یکیش همین میتونه باشه که وقتی ۱۰ تا یوسر جدید داریم به جای اینکه بیاییم یکی یکی بهشون دسترسی بدیم اونا عضو اون گروه بکنیم و خودش هندل بشه .
اینطوری میتونیم گروه هارو هم بهتر مدیریت کنیم .وقتی خواستیم ازش پرمیشن رو هم بگیریم از گروه حذفش میکنیم و دیگه نیازی نیست یک به یک دسترسی هارو ازش بگیریم.

11. In what special cases is assigning permissions directly to users justified?
به نظرم فقط موقع هایی که یک یوسر خاص داریم این کار میتونه موجه باشه یا برای یک تایم کوتاهی یک دسترسی رو داشته باشه میتونیم به صورت تکی و بدون استفاده از گروه بهش permission بدیم و یا مثلا یک یوسر عضو گروهی هست و به جز permission های اون گروه به permission های دیگه هم نیاز داره که اونو باید به صورت دستی بهش بدیم.


12. How can we restrict access so that only the owner of an object can edit it?
خب چند روش برای این کار داریم.تو اکثر این روش ها باید یک فیلد owner در داخل مدلمون تعریف کنیم .
به صورت دستی میتونیم این کار رو انجام بدیم و بیاییم چک کنیم که ایا این فرد owner هست یا نه .
یک روش دیگه این میتونه باشه که از Django rest استفاده کنیم و یک API براش بنویسیم.
روش دیگه این میتونه باشه که از UserPassesTestMixin استفاده کنیم و یک روش دیگه هم این که میتونیم از guardian استفاده کنیم.
13. What are the limitations of Django’s built-in permission system regarding object-level
access?
خب همانطور که دیدیم permission ها model-level هستن و object-levelنیستن و این یکی از محدودیت های این روش هست و اینکه نمیتوانیم پرمیشن را به یک شی خاص بدهیم و باید از روش های دیگری استفاده کنیم.

How can we combine ownership checks with model permissions?
خب برای این توضیح دادم که باید چیکار کنیم.
تو FBV ها نیاز داریم که با یک شرط چک کنیم که این request ای که آمده از اون یوسر مالک بوده یا نه و همچنین permission اون رو هم چک کنیم.
در CBV هم یک تابع test_func تعریف میکنیم و تو این مالکیت رو چک میکنیم و همچنین با permission_required هم پرمشن رو ایجاد میکنیم.
میتونیم از queryset استفاده کنیم  ولی خروجی این تو حالت غلط ۴۰۴ خواهد بود به جای ۴۰۳
یا اینکه از rest  استفاده کنیم و یک API بنویسیم.


16. How can we implement a reusable owner_required decorator?
خب هدف ما اینه که یک دیکریتور تعریف کنیم که  owner بودن اون رو چک کنه .
خب باید جوری باشه که اول چک کنه فرد لاگین کرده باشه و بعدش مالکیت اون رو چک کنه 
17. How can we write an OwnerOrPermissionMixin for class-based views?
خب برای این کار هم باید به تابعی بنویسیم که اول ابجکت رو بگیره  و بعدش چک کنه که یوسر پرمیشن داره یا نه و بعدش چک کنه که فرد مالک هست یا نه 
18. What are the best practices for keeping permission logic clean and testable?

منطق پرمیشن رو تا میتونیم خارج از ویو پیاده سازی کنیم با استفاده از دیکرتور ها یا میکسین ها 	
به جای نوشتن فانکشن ها از تابع های کمکی استفاده کنیم 
نیاییم با استفاده از اسم گروه یا رول پرمیشن رو تست کنیم و از تابع های biult-in استفاده کنیم 
از گروه ها استفاده کنیم
از ابجکت لول پرمیشن ها استفاده کنیم

19. What are Django signals and when should they be used?
خب سیگنال ها میان یه اتفاقی رو خبر میدن که این اتفاق افتاده میتونیم براش هندلر تعریف کنیم و وقتی این سگینال رو دریافات کردیم چه کارهایی رو انجام بدیم 
مثلا وقتی یک کاربر لاگین کرد سندر خود جنگو هستش و ما رسیور هستیم 
What is the post_save signal and how does it work?
خب این یکی از سیگنال های تعریف شده خود جنگو هستش که وقتی که یک نمونه ای توی دیتا بیس با موفقیت ذخیره میشه ارسال میشه .
 What is m2m_changed?
خب این سیگنال وقتی که یک رابطه many to many  تغییری انجام داده میشه مثل اضافه شدن یک ابجکت یا حذف شدن ارسال میشه و فرقش با بالایی این هستش که سیگنال بالایی وقتی که مدل لصلی تغییر کرد ارسال میشه ولی این سگینال وقتی ارسال میشه تو خود رابطه تغییری داشته باشیم  
What is post_migrate signal?
خب این سگینال همان طور که از اسمش پیداست وقتی که یک migrate موفق تو مدلمون داشته باشییم ارسال میشه و مربوط به یک مدل خاص نیست و مربوط به خود پروسه migrate هستش.
Why should we avoid heavy business logic inside signals?
خب این به خاطر اینه که اگر یک منطق سنگین بیاییم توی ی سیگنالی پیاده سازی کنیم چون هندل کردن خود سیگنال و کنترل و مدیریت اون سخته و همچنین برای دیباگ کردن هم سخته باعث افزایش سختی و مشکل میشه 




